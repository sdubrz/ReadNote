# 翻转图像

```
@author: sdubrz
@date: 2020.03.25
题目难度： 简单
原题链接 https://leetcode-cn.com/problems/flipping-an-image/
题目的著作权归领扣网络所有，商业转载请联系官方授权，非商业转载请注明出处。
解题代码转载请联系 lwyz521604#163.com
```

给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。

水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。

反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。

**示例 1：**

```
输入: [[1,1,0],[1,0,1],[0,0,0]]
输出: [[1,0,0],[0,1,0],[1,1,1]]
解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；
     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]
```

**示例 2：**

```
输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；
     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
```

**说明：**

+ 1 <= A.length = A[0].length <= 20
+ 0 <= A[i][j] <= 1

## 解决方法

很显然，不同的行之间的结果是互不影响的。因而，我们需要逐行进行操作。通过例子可以看出，在某一行中，每个元素位置最终的结果是其对称位置的元素取反。因而，可以很容易地实现一个时间复杂度为O(n^2)的解决方案。

```
class Solution {
    public int[][] flipAndInvertImage(int[][] A) {
        int n = A.length;
		int[][] B = new int[n][n];
		for(int i=0; i<n; i++) {
			for(int j=0; j<=(n-1)/2; j++) {			
				B[i][j] = 1 - A[i][n-1-j];
				B[i][n-1-j] = 1- A[i][j];
			}
		}
		return B;
    }
}
```

该版本实现的运行结果如下

```
执行用时 : 1 ms, 在所有 Java 提交中击败了68.21%的用户
内存消耗 : 41.7 MB, 在所有 Java 提交中击败了5.34%的用户
```

其中内存消耗高应该是新建了一个数组的原因，若改在原数组上操作，内存的问题应该可以解决掉。
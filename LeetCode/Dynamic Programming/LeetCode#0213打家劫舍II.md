# 打家劫舍II

```
@author: sdubrz
@date: 2020.04.17
题号： 213
题目难度： 中等
考察内容： 动态规划
原题链接 https://leetcode-cn.com/problems/house-robber-ii/
题目的著作权归领扣网络所有，商业转载请联系官方授权，非商业转载请注明出处。
解题代码转载请联系 lwyz521604#163.com
```

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈**，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你**在不触动警报装置的情况下**，能够偷窃到的最高金额。

**示例 1:**

```
输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

**示例 2:**

```
输入: [1,2,3,1]
输出: 4
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

通过次数29,468 提交次数78,830

## 解法

这道题是之前第198道打家劫舍的升级版。与之前不同的是这里房屋都围成了一圈，第1个房屋和第n个房屋是相邻的。所有的房屋形成了一个环状的结构。对于这个问题，我们可以随便挑出一间房屋，将这个环砍断，这样就可以把问题转化成之前第198题的问题了。如下图所示，对于第 n 间房，可以有两种选择：偷和不偷。当选择偷第 n 间房时，则一定不能偷第 1 间和第 n-1 间，则其结果就变成了对第 2 到第 n-2 个元素组成的子数组的无环版打家劫舍问题。如果选择不偷第 n 间房，则第 1 间和第 n-1 间都可以选择偷或者不偷，那么问题就变成了第 1 到第 n-1 个元素所组成的子数组的无环版打家劫舍问题。最后取这两种情况中收益较大的作为最终的结果。

![213](/images/213.png)

下面是Java实现的代码：

```
class Solution {
    public int rob(int[] nums) {
        if(nums.length==0){
            return 0;
        }
        if(nums.length<=3){
            int max = nums[0];
            for(int i=1; i<nums.length; i++){
                if(nums[i]>max)
                    max = nums[i];
            }
            return max;
        }
        int n = nums.length;
        int[] money1 = new int[n];  // 偷第n个
        int[] money2 = new int[n];  // 不偷第n个

        money1[1] = nums[1];
        money1[2] = Math.max(nums[1], nums[2]);
        for(int i=3; i<n-2; i++){
            money1[i] = Math.max(money1[i-2]+nums[i], money1[i-1]);
        }

        money2[0] = nums[0];
        money2[1] = Math.max(nums[0], nums[1]);
        for(int i=2; i<n-1; i++){
            money2[i] = Math.max(money2[i-2]+nums[i], money2[i-1]);
        }

        return Math.max(money1[n-3]+nums[n-1], money2[n-2]);
        
    }
}
```

在 LeetCode 系统中的提交结果如下：

```
执行结果：通过 显示详情
执行用时 : 0 ms, 在所有 Java 提交中击败了 100.00% 的用户
内存消耗 : 36.9 MB, 在所有 Java 提交中击败了 9.09% 的用户
```
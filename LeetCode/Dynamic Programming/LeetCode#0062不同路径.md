# 不同路径

```
@author: sdubrz
@date: 2020.04.18
题号： 62
题目难度： 中等
考察内容： 动态规划
原题链接 https://leetcode-cn.com/problems/unique-paths/
题目的著作权归领扣网络所有，商业转载请联系官方授权，非商业转载请注明出处。
解题代码转载请联系 lwyz521604#163.com
```

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

![62](/images/62.png)

例如，上图是一个7 x 3 的网格。有多少可能的路径？

 

**示例 1:**

```
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

**示例 2:**

```
输入: m = 7, n = 3
输出: 28
```

**提示：**

+ 1 <= m, n <= 100
+ 题目数据保证答案小于等于 2 * 10 ^ 9

## 解法

对于网格中的位置，最左边的一列和最上边的一行都只有一种走法。而对于其他任意位置的网格，有两类走法可以到达：
1. 从它左边的邻居网格到达
2. 从它上边的邻居网格到达

所以对于这种情况，到这个网格的走法数量等于到它左边网格的走法数量加上到它上边网格的走法数量。

这样，这个问题就可以解决了。

```
class Solution {
    public int uniquePaths(int m, int n) {
        if(m==1||n==1){
            return 1;
        }

        int[][] counts = new int[m][n];
        for(int i = 0; i<n; i++)
            counts[0][i] = 1;
        
        for(int i=1; i<m; i++){
            counts[i][0] = 1;
            for(int j=1; j<n; j++){
                counts[i][j] = counts[i][j-1]+counts[i-1][j];
            }
        }
        return counts[m-1][n-1];
        
    }
}
```

下面是在 LeetCode 系统中的提交结果：

```
执行结果： 通过 显示详情
执行用时 : 0 ms, 在所有 Java 提交中击败了 100.00% 的用户
内存消耗 : 36.1 MB, 在所有 Java 提交中击败了 6.35% 的用户
```
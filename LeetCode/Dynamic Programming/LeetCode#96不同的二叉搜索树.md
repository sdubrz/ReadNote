# 不同的二叉搜索树

```
@author: sdubrz
@date: 2020.04.25
题号： 96
题目难度： 中等
考察内容： 动态规划
原题链接 https://leetcode-cn.com/problems/unique-binary-search-trees/
题目的著作权归领扣网络所有，商业转载请联系官方授权，非商业转载请注明出处。
解题代码转载请联系 lwyz521604#163.com
```

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

**示例:**

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

通过次数40,278 提交次数61,717

## 解法

一般来讲，这种问题规模逐渐从1涨到 n 的，都会有一个递推关系，这种问题就可以考虑用动态规划的方法来解决。

对于以 1...n 为节点组成的二叉搜索树，可以根据其根节点进行一下分类。 1...n 都有可能为根节点，所以根节点总共有 n 种可能。假设以 x 为根节点，则左子树有 x-1 个节点，右子树有 n-x 个节点。左子树和右子树分别有多少种可能，又是一个递归的问题。所以以 x 为根节点时，总共有 $f(x-1)+f(n-x)$ 种可能的二叉搜索树。将所有根节点的情况加起来就是整个问题的解了。下面是 Java 程序的实现。

```
class Solution {
    public int numTrees(int n) {
        if(n<2){
            return 1;
        }

        int[] count = new int[n+1];
        count[0] = 1;
        count[1] = 1;
        for(int i=2; i<=n; i++){
            int sum = 0;
            for(int root=1; root<=i; root++){
                sum = sum + count[root-1]*count[i-root];
            }
            count[i] = sum;
        }

        return count[n];
    }
}
```

在 LeetCode 系统中提交的结果：

```
执行结果： 通过 显示详情
执行用时 : 0 ms, 在所有 Java 提交中击败了 100.00% 的用户
内存消耗 : 36.2 MB, 在所有 Java 提交中击败了 7.69% 的用户
```
## 书籍信息

```
作者：[美] Baron Scbwartz, Peter Zaitsev, Vadim Tkacbenko
译者：宁海元，周振兴，彭立勋，翟卫祥
电子工业出版社
```

## 第1章 MySQL架构与历史

```
@date: 2020-08-18
```

+ MySQL最重要的、最与众不同的特征是它的**存储引擎架构**，这种架构的设计**将查询处理（Query Processing）及其他系统任务（Server Task）和数据的存储/提取分离**。这种处理和存储分离的设计可以在使用时根据性能、特性，以及其他需求来选择数据存储的方式。

+ MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。

+ MySQL在两个层面的并发控制：**服务器层**和**存储引擎层**。

+ 两种类型的锁：
  + 共享锁（shared lock）也叫读锁（read lock）
  + 排他锁（exclusive lock）也叫写锁（write lock）

+ **表锁**（table lock）是MySQL中最基本的锁。
  
+ 写锁比读锁具有更好的优先级，因此一个写锁请求可能会被插入到读锁队列的前面。
  
+ **行锁**（row lock）可以最大程度地支持并发处理（同时也带来了最大的锁开销）。
  
+ 行锁只在存储引擎层实现，而MySQL服务器层没有实现。**服务器层完全不了解存储引擎中的锁实现**。
  
+ **事务**就是一组原子性的SQL查询，或者说是一个独立的工作单元。事务内的语句，**要么全部执行成功，要么全部执行失败**。

  + 可以用 ``START TRANSACTION`` 语句开始一个事务，然后要么使用 ``COMMIT`` 提交事务将修改的数据持久保留，要么使用 ``ROLLBACK`` 撤销所有的修改。大致为

    ```sql
    START TRANSACTION;
    SQL语句;
    COMMIT;
    ```

+ 事务的ACID：
  + **原子性**（atomicity）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。
  + **一致性**（consistency）：数据库总是从一个一致性的状态转换到另外一个一致性的状态。
  + **隔离性**（isolation）：**通常来说**，一个事务所做的修改在最终提交以前，对其他事务是不可见的。
  + **持久性**（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。

+ 四种隔离级别

  + **read uncommitted（未提交读）**

    事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据。这也被称为**脏读**（Dirty Read）。这个级别会导致很多问题，并且从性能上来讲，也不会比其他级别好太多，一般很少用。

  + **read committed（提交读）**

    大多数数据库的默认隔离级别。一个事物开始时，只能“看见”已经提交的事务所做的修改。即，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。

    有时又被称为**不可重复读**（nonrepeatable read），因为两次执行同样的查询可能会有不同的效果。

  + **repeatable read（可重复读）**

    解决了脏读的问题，保证了同一个事务中多次读取同样的记录的结果是一致的。但是还是无法解决另外一个**幻读**（Phantom read）的问题。

    **幻读**指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新记录，当之前的事务再次读取该范围的记录时，会产生**换行** <front color=blue>*这个词感觉不对，回头查下是不是幻行*</front>。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC）解决了幻读问题。

    **可重复读是MySQL的默认事务隔离级别**。

  + **serializable（可串行化）**

    强制事务串行执行，避免了前面说的幻读的问题。会在读取的每一行数据上加锁，很少用这个隔离级别。

  |     隔离级别     | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
  | :--------------: | :--------: | :--------------: | :--------: | :----: |
  | READ UNCOMMITTED |    YES     |       YES        |    YES     |   NO   |
  |  READ COMMITTED  |     NO     |       YES        |    YES     |   NO   |
  | REPEATABLE READ  |     NO     |        NO        |    YES     |   NO   |
  |   SERIALIZABLE   |     NO     |        NO        |     NO     |  YES   |

+ **死锁**

  InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚（这是相对比较简单的死锁回滚算法）。

  死锁发生之后，只有部分或者完全回滚其中一个事务，才能打破死锁。

+ 在事务中混合使用存储引擎

  MySQL服务器层不管理事务，事务是由下层的存储引擎实现的。所以**在同一个事务中，使用多种存储引擎是不可靠的**。

  如果在事务中混合使用了事务型和非事务型的表，在正常提交的情况下不会有什么问题。但如果事务需要回滚，**非事务型的表上的变更就无法撤销**。所以，为每张表选择合适的存储引擎非常重要。
  
+ **多版本并发控制（MVCC）**

+ 下面是在 ``REPEATABLE READ`` 隔离级别下，MVCC的操作

  + **SELECT**

    InnoDB会根据以下两个条件检查每行记录：

    + InnoDB只会查找版本早于当前事务版本的数据行（也就是说，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或修改过的。
    + 行的删除版本要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除。

    只有符合以上两个条件的记录，才可以作为查询结果返回。

  + **INSERT**

    InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

  + **DELETE**

    InnoDB为删除的每一行保存当前系统版本号作为行删除标志。

  + **UPDATE**

    InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。

  + **优缺点**

    保存两个额外系统版本号，使大多数操作都可以不用加锁。这样设计使得**读数据操作很简单，性能很好**，并且也能保证只会读取到符合标准的行。不足之处是每行记录都**需要额外的存储空间**，需要做更多的行检查工作，以及一些额外的维护工作。

    MVCC只在 **``REPEATABLE READ``** 和 **``READ COMMITTED``**两个隔离级别下工作。*其实在另外两个隔离级别下也没有意义*。

+ **MySQL的存储引擎**

  + **InnoDB** 。默认和推荐的存储引擎
  + **MyISAM**。不支持事务和行锁，崩溃后无法恢复。支持表锁，速度较慢。对于只读的数据，或者表比较小，可以忍受修复的操作比较合适。
  + **Archive**。 只支持insert和select操作，每次查询都需要执行全表扫描。不是一个事务型引擎，是一个对插入和压缩做了优化的简单引擎。
  + **CSV**引擎。可以将csv文件当做MySQL的表来处理
  + ……

## 第5章 创建高性能的索引

+ 索引（在MySQL中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。

### 5.1 索引基础

+ 在MySQL中，索引是在**存储引擎层**而不是服务器层实现的。所以并没有统一的索引标准。

#### B-Tree索引

+ 这本书这里说的B-Tree是一种广泛意义上的B-Tree，如包含InnoDB所采用的B+Tree。

+ B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。

+ 可以使用B-Tree索引的查询类型。B-Tree索引适用于**全键值**，**键值范围**或**键前缀**查找。其中键前缀查找只适用于**最左前缀**的查找。例如包含``(last_name, first_name, dob)``的索引，对如下类型的查找有效：

  + **全值匹配**

    指对索引中的所有列进行匹配。*例如查找姓名为 Cuba Allen、出生于1960-01-01的人*。

  + **匹配最左前缀**

    *如可以查找所有姓为Allen的人*。

  + **匹配列前缀**

    也可以只匹配某一列的值的开头部分。*如查找所有以 J 开头的姓的人*。

  + **匹配范围值**

    *例如查找姓在 Allen 和 Barrymore 之间的人*。

  + **精确匹配某一列并范围匹配另外一列**

    *如查找所有姓为 Allen，并且名字是以字母 K 开头的人。即第一列 last_name 全匹配，第二列 first_name 范围匹配*。

+ **关于B-Tree索引的限制**

  + 如果不是按照索引的最左列开始查找，则无法使用索引。
  + 不能跳过索引中的列。
  + 如果查询中有某个列的范围查找，则其右边所有的列都无法使用索引优化查找。



## 第6章 查询性能优化







## 第7章 MySQL高级特性





## 遇到的面试题

### 谈谈你对数据库索引的认识[Link](https://www.cnblogs.com/newpanderking/p/3781043.html)

+ 首先要明白无名无实莫要用索引：因为数据中的记录很多，为了方便我们查找，提高查询的效率。
+ **索引的原理：**
  + 对要查询的字段建立索引其实就是把该字段按照一定的方式排序；
  + 建立的索引只对该字段有用，如果查询的字段改变，那么这个索引也就无效了，比如图书馆的书是按照书名的第一个字母排序的，那么你想要找作者叫张三的就不能用改索引了；
  + 还有就是如果索引太多会降低查询的速度。
+ 首先明白**为什么索引会增加速度**，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。那么在任何时候都应该加索引么？这里有几个反例
  + 如果每次都需要取到所有表记录，无论如何都必须进行全表扫描了，那么是否加索引也没有意义了。
  + 对非唯一的字段，例如“性别”这种大量重复值的字段，增加索引也没有什么意义。
  + 对于记录比较少的表，增加索引不会带来速度的优化反而浪费了存储空间，因为索引是需要存储空间的，而且有个致命缺点是对于update/insert/delete的每次执行，字段的索引都必须重新计算更新。所以并不是任何情况下都改建立索引的.
+ **为什么要创建索引呢？**
  + 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
  + 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
  + 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
  + 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
  + 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

+ **创建索引的缺点**

  也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？这种想法固然有其合理性，然而也有其片面性。虽然，索引有许多优点，但是，为表中的每一个列都增加索引，是非常不明智的。这是因为，增加索引也有许多不利的一个方面。

  + 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
  + 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
  + 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

+ **创建方向索引的准则**

  索引是建立在数据库表中的某些列的上面。因此，在创建索引的时候，应该仔细考虑在哪些列上可以创建索引，在哪些列上不能创建索引。
  一般来说，**应该在这些列上创建索引：**

  + 在经常需要搜索的列上，可以加快搜索的速度；
  + 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
  + 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
  + 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
  + 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
  + 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 

  同样，对于有些列不应该创建索引。一般来说，**不应该创建索引的的这些列**具有下列特点

  + 对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
  +  对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
  + 对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
  + 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少 索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

+ 创建索引的方法

  创建索引有多种方法，这些方法包括直接创建索引的方法和间接创建索引的方法。

  + **直接创建索引**，例如使用CREATE INDEX语句或者使用创建索引向导。
  + **间接创建索引**，例如在表中定义主键约束或者唯一性键约束时，同时也创建了索引。

  虽然，这两种方法都可以创建索引，但是，它们创建索引的具体内容是有区别的。 
  使 用CREATE INDEX语句或者使用创建索引向导来创建索引，这是最基本的索引创建方式，并且这种方法最具有柔性，可以定制创建出符合自己需要的索引。在使用这种方式 创建索引时，可以使用许多选项，例如指定数据页的充满度、进行排序、整理统计信息等，这样可以优化索引。使用这种方法，可以指定索引的类型、唯一性和复合 性，也就是说，既可以创建聚簇索引，也可以创建非聚簇索引，既可以在一个列上创建索引，也可以在两个或者两个以上的列上创建索引。 
  通过定义主 键约束或者唯一性键约束，也可以间接创建索引。主键约束是一种保持数据完整性的逻辑，它限制表中的记录有相同的主键记录。在创建主键约束时，系统自动创建 了一个唯一性的聚簇索引。虽然，在逻辑上，主键约束是一种重要的结构，但是，在物理结构上，与主键约束相对应的结构是唯一性的聚簇索引。换句话说，在物理 实现上，不存在主键约束，而只存在唯一性的聚簇索引。同样，在创建唯一性键约束时，也同时创建了索引，这种索引则是唯一性的非聚簇索引。因此，当使用约束 创建索引时，索引的类型和特征基本上都已经确定了，由用户定制的余地比较小。 
  当在表上定义主键或者唯一性键约束时，如果表中已经有了使用 CREATE INDEX语句创建的标准索引时，那么主键约束或者唯一性键约束创建的索引覆盖以前创建的标准索引。也就是说，主键约束或者唯一性键约束创建的索引的优先 级高于使用CREATE INDEX语句创建的索引。

+ **索引的特征**

  索引有两个特征，即唯一性索引和复合索引。 
  + **唯一性索引**保证在索引列中的全部数据是唯一的，不会包含冗余数据。如果表中已经有一个主键约束或者唯一性键约束，那么当创建表或者修改表时，SQL Server自动创建一个唯一性索引。然而，如果必须保证唯一性，那么应该创建主键约束或者唯一性键约束，而不是创建一个唯一性索引。当创建唯一性索引 时，应该认真考虑这些规则：当在表中创建主键约束或者唯一性键约束时，SQL Server自动创建一个唯一性索引；如果表中已经包含有数据，那么当创建索引时，SQL Server检查表中已有数据的冗余性；每当使用插入语句插入数据或者使用修改语句修改数据时，SQL Server检查数据的冗余性：如果有冗余值，那么SQL Server取消该语句的执行，并且返回一个错误消息；确保表中的每一行数据都有一个唯一值，这样可以确保每一个实体都可以唯一确认；只能在可以保证实体 完整性的列上创建唯一性索引，例如，不能在人事表中的姓名列上创建唯一性索引，因为人们可以有相同的姓名。 
  + **复合索引**就是一个索引创建在两个列 或者多个列上。在搜索时，当两个或者多个列作为一个关键值时，最好在这些列上创建复合索引。当创建复合索引时，应该考虑这些规则：最多可以把16个列合并 成一个单独的复合索引，构成复合索引的列的总长度不能超过900字节，也就是说复合列的长度不能太长；在复合索引中，所有的列必须来自同一个表中，不能跨 表建立复合列；在复合索引中，列的排列顺序是非常重要的，因此要认真排列列的顺序，原则上，应该首先定义最唯一的列，例如在（COL1，COL2）上的索 引与在（COL2，COL1）上的索引是不相同的，因为两个索引的列的顺序不同；为了使查询优化器使用复合索引，查询语句中的WHERE子句必须参考复合 索引中第一个列；当表中有多个关键列时，复合索引是非常有用的；使用复合索引可以提高查询性能，减少在一个表中所创建的索引数量。 
## 书籍信息

```
作者：[美] Baron Scbwartz, Peter Zaitsev, Vadim Tkacbenko
译者：宁海元，周振兴，彭立勋，翟卫祥
电子工业出版社
```

## 第1章 MySQL架构与历史

```
@date: 2020-08-18
```

+ MySQL最重要的、最与众不同的特征是它的**存储引擎架构**，这种架构的设计**将查询处理（Query Processing）及其他系统任务（Server Task）和数据的存储/提取分离**。这种处理和存储分离的设计可以在使用时根据性能、特性，以及其他需求来选择数据存储的方式。

+ MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。

+ MySQL在两个层面的并发控制：**服务器层**和**存储引擎层**。

+ 两种类型的锁：
  + 共享锁（shared lock）也叫读锁（read lock）
  + 排他锁（exclusive lock）也叫写锁（write lock）

+ **表锁**（table lock）是MySQL中最基本的锁。
  
+ 写锁比读锁具有更好的优先级，因此一个写锁请求可能会被插入到读锁队列的前面。
  
+ **行锁**（row lock）可以最大程度地支持并发处理（同时也带来了最大的锁开销）。
  
+ 行锁只在存储引擎层实现，而MySQL服务器层没有实现。**服务器层完全不了解存储引擎中的锁实现**。
  
+ **事务**就是一组原子性的SQL查询，或者说是一个独立的工作单元。事务内的语句，**要么全部执行成功，要么全部执行失败**。

  + 可以用 ``START TRANSACTION`` 语句开始一个事务，然后要么使用 ``COMMIT`` 提交事务将修改的数据持久保留，要么使用 ``ROLLBACK`` 撤销所有的修改。大致为

    ```sql
    START TRANSACTION;
    SQL语句;
    COMMIT;
    ```

+ 事务的ACID：
  + **原子性**（atomicity）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。
  + **一致性**（consistency）：数据库总是从一个一致性的状态转换到另外一个一致性的状态。
  + **隔离性**（isolation）：**通常来说**，一个事务所做的修改在最终提交以前，对其他事务是不可见的。
  + **持久性**（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。

+ 四种隔离级别

  + **read uncommitted（未提交读）**

    事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据。这也被称为**脏读**（Dirty Read）。这个级别会导致很多问题，并且从性能上来讲，也不会比其他级别好太多，一般很少用。

  + **read committed（提交读）**

    大多数数据库的默认隔离级别。一个事物开始时，只能“看见”已经提交的事务所做的修改。即，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。

    有时又被称为**不可重复读**（nonrepeatable read），因为两次执行同样的查询可能会有不同的效果。

  + **repeatable read（可重复读）**

    解决了脏读的问题，保证了同一个事务中多次读取同样的记录的结果是一致的。但是还是无法解决另外一个**幻读**（Phantom read）的问题。

    **幻读**指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新记录，当之前的事务再次读取该范围的记录时，会产生**换行**。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC）解决了幻读问题。

    **可重复读是MySQL的默认事务隔离级别**。

  + **serializable（可串行化）**

    强制事务串行执行，避免了前面说的幻读的问题。会在读取的每一行数据上加锁，很少用这个隔离级别。

  |     隔离级别     | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
  | :--------------: | :--------: | :--------------: | :--------: | :----: |
  | READ UNCOMMITTED |    YES     |       YES        |    YES     |   NO   |
  |  READ COMMITTED  |     NO     |       YES        |    YES     |   NO   |
  | REPEATABLE READ  |     NO     |        NO        |    YES     |   NO   |
  |   SERIALIZABLE   |     NO     |        NO        |     NO     |  YES   |

+ **死锁**

  InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚（这是相对比较简单的死锁回滚算法）。

  死锁发生之后，只有部分或者完全回滚其中一个事务，才能打破死锁。

+ 在事务中混合使用存储引擎

  MySQL服务器层不管理事务，事务是由下层的存储引擎实现的。所以**在同一个事务中，使用多种存储引擎是不可靠的**。

  如果在事务中混合使用了事务型和非事务型的表，在正常提交的情况下不会有什么问题。但如果事务需要回滚，**非事务型的表上的变更就无法撤销**。所以，为每张表选择合适的存储引擎非常重要。
  
+ **多版本并发控制（MVCC）**

+ 下面是在 ``REPEATABLE READ`` 隔离级别下，MVCC的操作

  + **SELECT**

    InnoDB会根据以下两个条件检查每行记录：

    + InnoDB只会查找版本早于当前事务版本的数据行（也就是说，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或修改过的。
    + 行的删除版本要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除。

    只有符合以上两个条件的记录，才可以作为查询结果返回。

  + **INSERT**

    InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

  + **DELETE**

    InnoDB为删除的每一行保存当前系统版本号作为行删除标志。

  + **UPDATE**

    InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。

  + **优缺点**

    保存两个额外系统版本号，使大多数操作都可以不用加锁。这样设计使得**读数据操作很简单，性能很好**，并且也能保证只会读取到符合标准的行。不足之处是每行记录都**需要额外的存储空间**，需要做更多的行检查工作，以及一些额外的维护工作。

    MVCC只在 **``REPEATABLE READ``** 和 **``READ COMMITTED``**两个隔离级别下工作。*其实在另外两个隔离级别下也没有意义*。

+ **MySQL的存储引擎**

  + **InnoDB** 。默认和推荐的存储引擎
  + **MyISAM**。不支持事务和行锁，崩溃后无法恢复。支持表锁，速度较慢。对于只读的数据，或者表比较小，可以忍受修复的操作比较合适。
  + **Archive**。 只支持insert和select操作，每次查询都需要执行全表扫描。不是一个事务型引擎，是一个对插入和压缩做了优化的简单引擎。
  + **CSV**引擎。可以将csv文件当做MySQL的表来处理
  + ……

## 第5章 创建高性能的索引

+ 索引（在MySQL中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。

### 5.1 索引基础

+ 在MySQL中，索引是在**存储引擎层**而不是服务器层实现的。所以并没有统一的索引标准。

#### B-Tree索引

+ 这本书这里说的B-Tree是一种广泛意义上的B-Tree，如包含InnoDB所采用的B+Tree。

+ B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。

+ 可以使用B-Tree索引的查询类型。B-Tree索引适用于**全键值**，**键值范围**或**键前缀**查找。其中键前缀查找只适用于**最左前缀**的查找。例如包含``(last_name, first_name, dob)``的索引，对如下类型的查找有效：

  + **全值匹配**

    指对索引中的所有列进行匹配。*例如查找姓名为 Cuba Allen、出生于1960-01-01的人*。

  + **匹配最左前缀**

    *如可以查找所有姓为Allen的人*。

  + **匹配列前缀**

    也可以只匹配某一列的值的开头部分。*如查找所有以 J 开头的姓的人*。

  + **匹配范围值**

    *例如查找姓在 Allen 和 Barrymore 之间的人*。

  + **精确匹配某一列并范围匹配另外一列**

    *如查找所有姓为 Allen，并且名字是以字母 K 开头的人。即第一列 last_name 全匹配，第二列 first_name 范围匹配*。

+ **关于B-Tree索引的限制**

  + 如果不是按照索引的最左列开始查找，则无法使用索引。
  + 不能跳过索引中的列。
  + 如果查询中有某个列的范围查找，则其右边所有的列都无法使用索引优化查找。
# 第二部分 进程管理

## 第3章 进程

### 3.1 进程概念

+ 进程包括程序（文本段）、程序计数器、堆栈以及数据段等。
+ 进程状态：
  + 新的（new）
  + 运行（running）
  + 等待（waiting）
  + 就绪（ready）
  + 终止（terminated）
+ 进程控制块（PCB）包括：
  + 进程状态
  + 程序计数器
  + CPU寄存器
  + CPU调度信息
  + 内存管理信息
  + 记账信息
  + I/O状态信息

### 3.2 进程调度

+ **多道程序设计**的目标是，无论何时都有进程运行，从而最大化CPU利用率。
+ **分时系统**的目的是在进程之间快速切换CPU，以便用户在程序运行时能与其交互。
+ 等待CPU的有个就绪队列来存放进程，等待某个设备的也有相应的设备队列。
+ **长期调度程序**和**短期调度程序**。
  + 长期调度程序从缓冲池中选择进程，加到**内存**，以便执行。
  + 短期调度程序从准备执行的进程中选择进程，并分配**CPU**。
  + 这两种调度程序的主要区别是**执行频率**，短期调度必须经常为CPU选择新的进程，而长期调度程序执行并不频繁。重要的是，**长期调度程序进行认真选择**。

### 3.4 进程间通信

+ 提供环境允许进程协作的理由：
  + **信息共享**。
  + **计算加速**
  + **模块化**
  + **方便**：即使单个用户也可能同时执行很多任务。例如，用户可以并行地编辑、收听音乐、编译。
+ 进程间通信有两种基本模型：**共享内存**和**消息传递**。
  + 共享内存模型会建立起一块供协作进程共享的内存区域，进程通过向此共享区域读出或写入数据来交换信息。
  + 消息传递模型通过协作进程间交换消息来实现通信。
  + 消息传递对于交换较少数量的数据很有用，因为无需避免冲突。共享内存可以快于消息传递，这是因为消息传递的实现进场采用系统调用，因此需要消耗更多时间以便内核介入。与此相反，共享内存系统仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有访问都可以作为常规内存访问，无需借助内核。

### 3.6 客户机/服务器通信

+ 共享内存和消息传递这两种技术也可以用于客户机/服务器系统的通信。客户机/服务器系统还有其他三种策略：套接字、远程程序调用和管道。



## 第4章 多线程编程

### 4.1 概述

+ 动机：进程创建很耗时间和资源。如果新进程与原进程执行同样的任务，为什么要承担所有这些开销。
+ 多线程编程的优点：
  + **响应性**。如果一个交互程序采用多线程，那么即使部分阻塞或者执行冗长操作，它仍可以继续执行，从而增加对用户的响应程度。
  + **资源共享**。进程只能通过共享内存或消息传递之类的技术共享内存，并且需要程序员显示地安排。而线程默认共享它们所属进程的内存和资源。
  + **经济**
  + **可伸缩性**。对于多处理器体系结构，线程可以在多处理核上并行运行。

### 4.3 多线程模型

+ 多对一模型。映射多个用户线程到一个内核线程。
+ 一对一模型。映射每个用户线程到一个内核线程。
+ 多对多模型。多路复用多个用户线程到同样数量或更少数量的内核线程。

### 4.5 隐式多线程

+ 将多线程的创建与管理交给编译器和运行时库来完成。这种策略称为**隐式线程**（implicit threading）。
+ **线程池的主要思想**是：在进程开始时，创建一定数量的线程，并加到池中以等待工作。当服务器收到请求时，它会唤醒池内的一个线程（如果有可用线程），并将需要服务的请求传递给它。一旦线程完成了服务，它会返回池中再等待工作。如果池中没有可用线程，那么服务器会等待，直到有空线程为止。
+ **线程池的优点**：
  + 用现有线程服务请求比等待创建一个线程更快。
  + 线程池限制了在任何时候可用线程的数量。对于不能支持大量并发线程的系统比较重要。
  + 将要执行的任务从创建任务的机制中分离出来，允许我们采用不同策略运行任务。如定期执行等。

## 第5章 进程调度

### 5.1 基本概念

+ 需要CPU调度的情况可以分为以下四种：
  + 当一个进程从运行状态切换到等待状态时。如I/O请求，或wait()调用，以便等待一个子进程终止。
  + 当一个进程从运行状态切换到就绪状态时。如出现中断时。
  + 当一个进程从等待状态切换到就绪状态时。如I/O完成时。
  + 当一个进程终止时。

### 5.3 调度算法

+ **先到先服务（FCFS）**。缺点是平均等待时间往往很长。
+ **最短作业优先调度（SJF）**。经常用于长期调度。虽然SJF是最优的，但是不能在短期CPU调度级别上实现，因为不知道下次CPU执行的长度。
+ **优先级调度**。低优先级进程的无穷等待问题的解决方案之一是老化。逐渐增加在系统中等待时间很长的进程的优先级。
+ **轮转调度（RR）**。
+ **多级队列调度**。将就绪队列分成多个单独队列，一个进程被永久分到一个队列。每个队列有自己的调度算法，不同队列之间通常采用固定优先级抢占调度。
+ **多级反馈队列调度**。允许进程在队列之间迁移。

## 第6章 同步

